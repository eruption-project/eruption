/*  SPDX-License-Identifier: GPL-3.0-or-later  */

/*
    This file is part of Eruption.

    Eruption is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Eruption is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Eruption.  If not, see <http://www.gnu.org/licenses/>.

    Copyright (c) 2019-2023, The Eruption Development Team
*/

#[cfg(not(target_os = "windows"))]
use evdev_rs::enums::EV_KEY;
use parking_lot::Mutex;
use std::{mem::size_of, time::Duration};

use std::sync::Arc;
use tracing::*;

use crate::hwdevices::{KeyboardHidEvent, KeyboardHidEventCode};
#[allow(unused)]
use crate::{constants, eprintln_v, println_v};

use super::{DeviceTrait, HwDeviceError, RGBA};

pub type Result<T> = super::Result<T>;

#[allow(unused)]
pub const CTRL_INTERFACE: i32 = 1; // Control USB sub device

#[allow(unused)]
pub const LED_INTERFACE: i32 = 2; // LED USB sub device

pub const NUM_ROWS: usize = 6;
pub const NUM_COLS: usize = 21;
#[allow(unused)]
pub const NUM_LEDS: usize = NUM_ROWS * NUM_COLS;
pub const NUM_KEYS: usize = 127;
// pub const NUM_RGB: usize = 196;
pub const LED_INDICES: usize = 127;

// Wooting protocol v2 constants
// pub const COMMAND_SIZE: usize = 8;
// pub const REPORT_SIZE: usize = 256 + 1;
pub const SMALL_PACKET_SIZE: usize = 64;
pub const SMALL_PACKET_COUNT: usize = 4;
pub const RESPONSE_SIZE: usize = 256;
pub const READ_RESPONSE_TIMEOUT: i32 = 1000;

/// Wooting protocol v2 commands
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy)]
#[repr(u8)]
enum Command {
    RAW_COLORS_REPORT = 11,
    // DEVICE_CONFIG_COMMAND = 19,
    // SINGLE_COLOR_COMMAND = 30,
    // SINGLE_RESET_COMMAND = 31,
    RESET_ALL_COMMAND = 32,
    COLOR_INIT_COMMAND = 33,
}

#[derive(Clone)]
/// Device specific code for the Wooting Two HE series keyboards
pub struct WootingTwoHeArm {
    pub is_bound: bool,
    pub ctrl_hiddev: Arc<Mutex<Option<hidapi::HidDevice>>>,
    pub led_hiddev: Arc<Mutex<Option<hidapi::HidDevice>>>,
}

impl WootingTwoHeArm {
    /// Binds the driver to the supplied HID devices
    #[allow(dead_code)]
    pub fn bind(ctrl_dev: hidapi::HidDevice, led_dev: hidapi::HidDevice) -> Self {
        println_v!(1, "Bound driver: Wooting Two HE (ARM)");

        Self {
            is_bound: true,
            ctrl_hiddev: Arc::new(Mutex::new(Some(ctrl_dev))),
            led_hiddev: Arc::new(Mutex::new(Some(led_dev))),
        }
    }

    // pub(self) fn query_ctrl_report(&self, id: u8) -> Result<()> {
    //     println_v!(0, "Querying control device feature report");

    //     if !self.is_bound {
    //         Err(HwDeviceError::DeviceNotBound {}.into())
    //     } else {
    //         match id {
    //             0x0f => {
    //                 let mut buf: [u8; 256] = [0; 256];
    //                 buf[0] = id;

    //                 let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
    //                 let ctrl_dev = ctrl_dev.as_ref().unwrap();

    //                 match ctrl_dev.get_feature_report(&mut buf) {
    //                     Ok(_result) => {
    //         #[cfg(debug_assertions)]
    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

    //                         Ok(())
    //                     }

    //                     Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
    //                 }
    //             }

    //             _ => Err(HwDeviceError::InvalidStatusCode {}.into()),
    //         }
    //     }
    // }

    fn v2_send_feature_report(&self, id: u8, params: &[u8; 4]) -> Result<()> {
        trace!("Sending control device feature report [Wooting v2]");

        let mut report_buffer = [0x0; SMALL_PACKET_SIZE + 1];

        report_buffer[0] = 0x00;
        report_buffer[1] = 0xd0;
        report_buffer[2] = 0xda;
        report_buffer[3] = id;
        report_buffer[4] = params[3];
        report_buffer[5] = params[2];
        report_buffer[6] = params[1];
        report_buffer[7] = params[0];

        let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
        let ctrl_dev = ctrl_dev.as_ref().unwrap();

        let result = ctrl_dev.write(&report_buffer);

        match result {
            Ok(_result) => {
                hexdump::hexdump_iter(&report_buffer).for_each(|s| trace!("  {}", s));

                let mut buf = Vec::with_capacity(RESPONSE_SIZE);
                match ctrl_dev.read_timeout(&mut buf, READ_RESPONSE_TIMEOUT) {
                    Ok(_result) => {
                        //         #[cfg(debug_assertions)]
                        //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

                        Ok(())
                    }

                    Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
                }
            }

            Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
        }
    }

    #[allow(dead_code)]
    fn send_ctrl_report(&self, _id: u8) -> Result<()> {
        println_v!(1, "Sending control device feature report");

        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            // let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
            // let ctrl_dev = ctrl_dev.as_ref().unwrap();

            // match id {
            //     0x00 => {
            //         let buf: [u8; 1] = [0x00];

            //         match ctrl_dev.send_feature_report(&buf) {
            //             Ok(_result) => {
            //                //         #[cfg(debug_assertions)]
            //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

            //                 Ok(())
            //             }

            //             Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
            //         }
            //     }

            //     _ => Err(HwDeviceError::InvalidStatusCode {}.into()),
            // }

            Ok(())
        }
    }

    #[allow(dead_code)]
    fn send_led_data(&self, id: u8) -> Result<()> {
        println_v!(0, "Sending data to LED device");

        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            // let led_dev = self.ctrl_hiddev.as_ref().lock();
            // let led_dev = led_dev.as_ref().unwrap();

            match id {
                0xa1 => {
                    // let buf: [u8; 64] = [
                    //     0xa1, 0x01, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00,
                    // ];

                    // match led_dev.write(&buf) {
                    //     Ok(_result) => {
                    //        //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));
                    //     }

                    //     Err(_) => return Err(HwDeviceError::InvalidResult {}.into()),
                    // }

                    // let buf: [u8; 64] = [
                    //     0xa1, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00,
                    // ];

                    // match led_dev.write(&buf) {
                    //     Ok(_result) => {
                    //        //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));
                    //     }

                    //     Err(_) => return Err(HwDeviceError::InvalidResult {}.into()),
                    // }

                    // let buf: [u8; 64] = [
                    //     0xa1, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00,
                    // ];

                    // match led_dev.write(&buf) {
                    //     Ok(_result) => {
                    //        //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));
                    //     }

                    //     Err(_) => return Err(HwDeviceError::InvalidResult {}.into()),
                    // }

                    // let buf: [u8; 64] = [
                    //     0xa1, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00,
                    // ];

                    // match led_dev.write(&buf) {
                    //     Ok(_result) => {
                    //        //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));
                    //     }

                    //     Err(_) => return Err(HwDeviceError::InvalidResult {}.into()),
                    // }

                    // let buf: [u8; 64] = [
                    //     0xa1, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    //     0x00, 0x00, 0x00, 0x00,
                    // ];

                    // match led_dev.write(&buf) {
                    //     Ok(_result) => {
                    //        //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));
                    //     }

                    //     Err(_) => return Err(HwDeviceError::InvalidResult {}.into()),
                    // }

                    Ok(())
                }

                _ => Err(HwDeviceError::InvalidStatusCode {}.into()),
            }
        }
    }

    fn wait_for_ctrl_dev(&self) -> Result<()> {
        trace!("Waiting for control device to respond...");

        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            let mut buf: [u8; RESPONSE_SIZE] = [0x00; RESPONSE_SIZE];

            let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
            let ctrl_dev = ctrl_dev.as_ref().unwrap();

            match ctrl_dev.read_timeout(&mut buf, READ_RESPONSE_TIMEOUT) {
                Ok(_result) => {
                    //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

                    Ok(())
                }

                Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
            }
        }
    }

    // #[allow(dead_code)]
    // fn wait_for_led_dev(&mut self) -> Result<()> {
    //     trace!("Waiting for LED device to respond...");

    //     if !self.is_bound {
    //         Err(HwDeviceError::DeviceNotBound {}.into())
    //     } else {
    //         let mut buf: [u8; RESPONSE_SIZE] = [0x00; RESPONSE_SIZE];

    //         let led_dev = self.led_hiddev.as_ref().lock();
    //         let led_dev = led_dev.as_ref().unwrap();

    //         match led_dev.read_timeout(&mut buf, READ_RESPONSE_TIMEOUT) {
    //             Ok(_result) => {
    //                //         #[cfg(debug_assertions)]
    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

    //                 Ok(())
    //             }

    //             Err(_) => return Err(HwDeviceError::InvalidResult {}.into()),
    //         }
    //     }
    // }
}

impl DeviceTrait for WootingTwoHeArm {
    fn send_init_sequence(&self) -> Result<()> {
        println_v!(1, "Sending device init sequence...");

        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            println_v!(1, "Step 1");
            self.v2_send_feature_report(Command::RESET_ALL_COMMAND as u8, &[0, 0, 0, 0])
                .unwrap_or_else(|e| error!("Step 1: {}", e));
            self.wait_for_ctrl_dev()
                .unwrap_or_else(|e| error!("Step 1: {}", e));

            println_v!(1, "Step 2");
            self.v2_send_feature_report(Command::COLOR_INIT_COMMAND as u8, &[0, 0, 0, 0])
                .unwrap_or_else(|e| error!("Step 1: {}", e));
            self.wait_for_ctrl_dev()
                .unwrap_or_else(|e| error!("Step 1: {}", e));

            Ok(())
        }
    }

    fn write_data_raw(&self, buf: &[u8]) -> Result<()> {
        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
            let ctrl_dev = ctrl_dev.as_ref().unwrap();

            match ctrl_dev.write(buf) {
                Ok(_result) => {
                    hexdump::hexdump_iter(buf).for_each(|s| trace!("  {}", s));

                    Ok(())
                }

                Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
            }
        }
    }

    fn read_data_raw(&self, size: usize) -> Result<Vec<u8>> {
        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
            let ctrl_dev = ctrl_dev.as_ref().unwrap();

            let mut buf = Vec::new();
            buf.resize(size, 0);

            match ctrl_dev.read(buf.as_mut_slice()) {
                Ok(_result) => {
                    //         #[cfg(debug_assertions)]
                    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

                    Ok(buf)
                }

                Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
            }
        }
    }

    // fn write_feature_report(&self, buffer: &[u8]) -> Result<()> {
    //     if !self.is_bound {
    //         Err(HwDeviceError::DeviceNotBound {}.into())
    //     } else {
    //         let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
    //         let ctrl_dev = ctrl_dev.as_ref().unwrap();

    //         match ctrl_dev.send_feature_report(buffer) {
    //             Ok(_result) => {
    //                 hexdump::hexdump_iter(buffer).for_each(|s| trace!("  {}", s));

    //                 Ok(())
    //             }

    //             Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
    //         }
    //     }
    // }

    // fn read_feature_report(&self, id: u8, size: usize) -> Result<Vec<u8>> {
    //     if !self.is_bound {
    //         Err(HwDeviceError::DeviceNotBound {}.into())
    //     } else {
    //         let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
    //         let ctrl_dev = ctrl_dev.as_ref().unwrap();

    //         let mut buf = Vec::new();
    //         buf.resize(size, 0);
    //         buf[0] = id;

    //         match ctrl_dev.get_feature_report(buf.as_mut_slice()) {
    //             Ok(_result) => {
    //                //         #[cfg(debug_assertions)]
    //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));

    //                 Ok(buf)
    //             }

    //             Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
    //         }
    //     }
    // }

    fn get_num_keys(&self) -> usize {
        NUM_KEYS
    }

    fn get_num_rows(&self) -> usize {
        NUM_ROWS
    }

    fn get_num_cols(&self) -> usize {
        NUM_COLS
    }

    fn get_row_topology(&self) -> Vec<u8> {
        ROWS_TOPOLOGY.to_vec()
    }

    fn get_col_topology(&self) -> Vec<u8> {
        COLS_TOPOLOGY.to_vec()
    }

    fn get_neighbor_topology(&self) -> Vec<u8> {
        NEIGHBOR_TOPOLOGY.to_vec()
    }

    fn send_led_map(&self, led_map: &[RGBA]) -> Result<()> {
        println_v!(1, "Setting LEDs from supplied map...");

        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            match *self.led_hiddev.lock() {
                Some(ref led_dev) => {
                    if led_map.len() < LED_INDICES {
                        error!(
                            "Received a short LED map: Got {} elements, but should be {}",
                            led_map.len(),
                            LED_INDICES
                        );

                        Err(HwDeviceError::LedMapError {}.into())
                    } else {
                        #[inline]
                        fn encode_color(color: &RGBA) -> u16 {
                            let mut encoded_color: u16 = 0x0000;

                            encoded_color |= (color.b as u16 & 0xf8) >> 3;
                            encoded_color |= (color.g as u16 & 0xfc) << 3;
                            encoded_color |= (color.r as u16 & 0xf8) << 8;

                            encoded_color
                        }

                        #[inline]
                        #[allow(dead_code)]
                        fn index_of(cntr: usize) -> Option<usize> {
                            // let x = cntr / NUM_COLS;
                            // let y = cntr % NUM_COLS;

                            TOPOLOGY.get(cntr).cloned().and_then(|v| {
                                if v == 0xff {
                                    None
                                } else {
                                    Some(v as usize)
                                }
                            })
                        }

                        #[inline]
                        fn submit_packet(led_dev: &hidapi::HidDevice, buffer: &[u8]) -> Result<()> {
                            hexdump::hexdump_iter(buffer).for_each(|s| trace!("  {}", s));

                            assert_eq!(buffer.len(), SMALL_PACKET_SIZE + 1);

                            match led_dev.write(buffer) {
                                Ok(len) => {
                                    if len < SMALL_PACKET_SIZE + 1 {
                                        return Err(HwDeviceError::WriteError {}.into());
                                    }

                                    // let mut buf: [u8; RESPONSE_SIZE] = [0x00; RESPONSE_SIZE];
                                    // match led_dev.read_timeout(&mut buf, 50) {
                                    //     Ok(_result) => {
                                    //         hexdump::hexdump_iter(&buf)
                                    //             .for_each(|s| println_v2!("  {}", s));
                                    //     }

                                    //     Err(_) => {
                                    //         return Err(HwDeviceError::InvalidResult {}.into())
                                    //     }
                                    // }

                                    std::thread::sleep(Duration::from_millis(10));
                                }

                                Err(_) => return Err(HwDeviceError::WriteError {}.into()),
                            }

                            Ok(())
                        }

                        const BUFFER_SIZE: usize =
                            4 + (SMALL_PACKET_COUNT * (SMALL_PACKET_SIZE + 1)) + 2;
                        let mut buffer = [0x0_u8; BUFFER_SIZE];
                        let mut cntr = 0;

                        // let led_map = led_map
                        //     .iter()
                        //     .enumerate()
                        //     .map(|(idx, _c)| led_map[index_of(idx)])
                        //     .collect::<Vec<_>>();

                        // init sequence
                        buffer[0..4].copy_from_slice(&[
                            0x00,
                            0xd0,
                            0xda,
                            Command::RAW_COLORS_REPORT as u8,
                        ]);

                        // encoded color sequence and submit a packet on every 64th byte to the device
                        for i in (4..BUFFER_SIZE).step_by(2) {
                            if i % 64 == 0 {
                                buffer[i] = 0x0;
                                submit_packet(led_dev, &buffer[(i - 64)..=i])?;
                            } else {
                                let index = cntr / size_of::<RGBA>();
                                let encoded_color =
                                            // encode_color(&led_map[index_of(cntr).unwrap_or(0x0)]);
                                            encode_color(led_map.get(index).unwrap_or(&RGBA {
                                                r: 0x00,
                                                g: 0x00,
                                                b: 0x00,
                                                a: 0x00,
                                            }));

                                buffer[i..i + 2].copy_from_slice(&encoded_color.to_le_bytes());

                                cntr += 1;
                            }
                        }

                        Ok(())
                    }
                }

                None => Err(HwDeviceError::DeviceNotOpened {}.into()),
            }
        }
    }

    fn get_next_event_timeout(&self, millis: i32) -> Result<KeyboardHidEvent> {
        trace!("Querying control device for next event");

        if !self.is_bound {
            Err(HwDeviceError::DeviceNotBound {}.into())
        } else {
            let ctrl_dev = self.ctrl_hiddev.as_ref().lock();
            let ctrl_dev = ctrl_dev.as_ref().unwrap();

            let mut buf = [0; 8];

            match ctrl_dev.read_timeout(&mut buf, millis) {
                Ok(_size) => {
                    if buf.iter().any(|e| *e != 0) {
                        //         #[cfg(debug_assertions)]
                        //         hexdump::hexdump_iter(&buf).for_each(|s| trace!("  {}", s));
                    }

                    let event = match buf[0..5] {
                        // Key reports, incl. KEY_FN, ..
                        [0x03, 0x00, 0xfb, code, status] => match status {
                            0x00 => KeyboardHidEvent::KeyUp {
                                code: KeyboardHidEventCode::Unknown(code),
                            },

                            0x01 => KeyboardHidEvent::KeyDown {
                                code: KeyboardHidEventCode::Unknown(code),
                            },

                            _ => KeyboardHidEvent::Unknown,
                        },

                        // CAPS LOCK, Easy Shift+, ..
                        [0x03, 0x00, 0x0a, code, status] => match code {
                            0x39 | 0xff => match status {
                                0x00 => KeyboardHidEvent::KeyDown {
                                    code: KeyboardHidEventCode::Unknown(code),
                                },

                                0x01 => KeyboardHidEvent::KeyUp {
                                    code: KeyboardHidEventCode::Unknown(code),
                                },

                                _ => KeyboardHidEvent::Unknown,
                            },

                            _ => KeyboardHidEvent::Unknown,
                        },

                        _ => KeyboardHidEvent::Unknown,
                    };

                    Ok(event)
                }

                Err(_) => Err(HwDeviceError::InvalidResult {}.into()),
            }
        }
    }

    #[cfg(not(target_os = "windows"))]
    fn ev_key_to_key_index(&self, key: EV_KEY) -> u8 {
        EV_TO_INDEX_ISO[(key as u8) as usize].saturating_add(1)
    }

    fn hid_event_code_to_key_index(&self, code: &KeyboardHidEventCode) -> u8 {
        match code {
            KeyboardHidEventCode::KEY_FN => 77,

            KeyboardHidEventCode::KEY_CAPS_LOCK => 4,
            KeyboardHidEventCode::KEY_EASY_SHIFT => 4,

            // We don't need all the other key codes, for now
            _ => 0,
        }
    }

    fn hid_event_code_to_report(&self, code: &KeyboardHidEventCode) -> u8 {
        match code {
            KeyboardHidEventCode::KEY_F1 => 16,
            KeyboardHidEventCode::KEY_F2 => 24,
            KeyboardHidEventCode::KEY_F3 => 33,
            KeyboardHidEventCode::KEY_F4 => 32,

            KeyboardHidEventCode::KEY_F5 => 40,
            KeyboardHidEventCode::KEY_F6 => 48,
            KeyboardHidEventCode::KEY_F7 => 56,
            KeyboardHidEventCode::KEY_F8 => 57,

            KeyboardHidEventCode::KEY_ESC => 17,
            KeyboardHidEventCode::KEY_FN => 119,

            KeyboardHidEventCode::KEY_CAPS_LOCK => 57,
            KeyboardHidEventCode::KEY_EASY_SHIFT => 57,

            KeyboardHidEventCode::Unknown(code) => *code,
        }
    }
}

/// Map evdev event codes to key indices, for ISO variant
#[rustfmt::skip]
const EV_TO_INDEX_ISO: [u8; 0x2ff + 1] = [
    0xff, 0x02, 0x08, 0x0e, 0x15, 0x1a, 0x1f, 0x24, 0x29, 0x30, 0x36, 0x3c, 0x42, 0x48, 0x50, 0x04,
    0x09, 0x0f, 0x16, 0x1b, 0x20, 0x25, 0x2a, 0x31, 0x37, 0x3d, 0x43, 0x49, 0x52, 0x01, 0x0a, 0x10,
    0x17, 0x1c, 0x21, 0x26, 0x2b, 0x32, 0x38, 0x3e, 0x44, 0x03, 0x00, 0x4a, 0x0b, 0x11, 0x18, 0x1d,
    0x22, 0x27, 0x2c, 0x33, 0x39, 0x3f, 0x4b, 0xff, 0x0c, 0x23, 0x05, 0x0d, 0x14, 0x19, 0x1e, 0x28,
    0x2f, 0x35, 0x3b, 0x41, 0x47, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x4d, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x4c, 0xff, 0xff, 0x3a, 0xff, 0x58, 0x5a, 0x5d, 0x56, 0x5f, 0x59, 0x5b, 0x5e, 0x54, 0x55,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0x46,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

/// Map evdev event codes to key indices, for ANSI variant
#[rustfmt::skip]
const _EV_TO_INDEX_ANSI: [u8; 0x2ff + 1] = [
    0xff, 0x00, 0x06, 0x0c, 0x12, 0x18, 0x1d, 0x21, 0x31, 0x36, 0x3c, 0x42, 0x48, 0x4f, 0x57,
    0x02, // 0x000
    0x07, 0x0d, 0x13, 0x19, 0x1e, 0x22, 0x32, 0x37, 0x3d, 0x43, 0x49, 0x50, 0x58, 0x05, 0x08,
    0x0e, // 0x010
    0x14, 0x1a, 0x1f, 0x23, 0x33, 0x38, 0x3e, 0x44, 0x4a, 0x01, 0x04, 0x51, 0x0f, 0x15, 0x1b,
    0x20, // 0x020
    0x24, 0x34, 0x39, 0x3f, 0x45, 0x4b, 0x52, 0x7c, 0x10, 0x25, 0x03, 0x0b, 0x11, 0x17, 0x1c,
    0x30, // 0x030
    0x35, 0x3b, 0x41, 0x4e, 0x54, 0x71, 0x67, 0x72, 0x78, 0x7d, 0x81, 0x73, 0x79, 0x7e, 0x82,
    0x74, // 0x040
    0x7a, 0x7f, 0x75, 0x80, 0xff, 0xff, 0xff, 0x55, 0x56, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x050
    0x83, 0x59, 0x77, 0x63, 0x46, 0xff, 0x68, 0x6a, 0x6d, 0x66, 0x6f, 0x69, 0x6b, 0x6e, 0x64,
    0x65, // 0x060
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6c, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0xff,
    0x53, // 0x070
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x080
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x090
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x0a0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x0b0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x0c0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x0d0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x0e0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x0f0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x100
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x110
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x120
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x130
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x140
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x150
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x160
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x170
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x180
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x190
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x1a0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x1b0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x1c0
    0x4c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x1d0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x1e0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x1f0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x200
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x210
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x220
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x230
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x240
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x250
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x260
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x270
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x280
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x290
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x2a0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x2b0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x2c0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x2d0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x2e0
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, // 0x2f0
];

const NOKEY: u8 = 0xff;

#[rustfmt::skip]
#[allow(dead_code)]
pub const TOPOLOGY: [u8; 126] = [
    0, NOKEY, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 107, 108, 109, 110,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 61, 106, 105, 104, 103,
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 62, 102, 101, 100, 99,
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 45, 60, NOKEY, NOKEY, NOKEY, 98, 97, 96, NOKEY,
    64, 87, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, NOKEY, 75, NOKEY, 63, NOKEY, 90, 91, 92, 93,
    80, 81, 82, NOKEY, NOKEY, NOKEY, 83, NOKEY, NOKEY, NOKEY, 84, 85, 86, 79, 76, 77, 78, NOKEY, 95, 94, NOKEY
];

// Neighbor topology map
#[rustfmt::skip]
pub static NEIGHBOR_TOPOLOGY: [u8; 2900] = [
    // ISO model
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // sentinel
	0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x00
	0x00, 0x02, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x01
	0x01, 0x03, 0x06, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x02
	0x02, 0x04, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x03
	0x03, 0x05, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x04
	0x04, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x05
	0x01, 0x02, 0x07, 0x0c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x06
	0x02, 0x06, 0x08, 0x0c, 0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x07
	0x03, 0x07, 0x09, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x08
	0x03, 0x04, 0x08, 0x0a, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x09
	0x05, 0x09, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0a
	0x0c, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0b
	0x06, 0x07, 0x0b, 0x0d, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0c
	0x07, 0x0c, 0x0e, 0x12, 0x13, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0d
	0x08, 0x0d, 0x0f, 0x14, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0e
	0x08, 0x09, 0x0e, 0x10, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0f
	0x0a, 0x0f, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x10
	0x0b, 0x12, 0x17, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x11
	0x0c, 0x0d, 0x11, 0x13, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x12
	0x0d, 0x12, 0x14, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x13
	0x0e, 0x13, 0x15, 0x1a, 0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x14
	0x0e, 0x0f, 0x10, 0x14, 0x1b, 0x25, 0xff, 0xff, 0xff, 0xff, // 0x15
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x16
	0x11, 0x18, 0x1c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x17
	0x12, 0x13, 0x17, 0x19, 0x1d, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x18
	0x13, 0x18, 0x1a, 0x1d, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x19
	0x14, 0x19, 0x1b, 0x1f, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1a
	0x14, 0x15, 0x1a, 0x20, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1b
	0x17, 0x1d, 0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1c
	0x18, 0x19, 0x1c, 0x1e, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1d
	0x19, 0x1d, 0x1f, 0x21, 0x22, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1e
	0x1a, 0x1e, 0x20, 0x23, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1f
	0x1a, 0x1b, 0x1f, 0x24, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x20
	0x1d, 0x1e, 0x22, 0x30, 0x31, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x21
	0x1e, 0x21, 0x23, 0x31, 0x32, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x22
	0x1f, 0x22, 0x24, 0x33, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x23
	0x1f, 0x20, 0x23, 0x25, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x24
	0x10, 0x15, 0x1b, 0x20, 0x24, 0x34, 0x39, 0x3f, 0x46, 0xff, // 0x25
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x26
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x27
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x28
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x29
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2b
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2d
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2e
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2f
	0x1c, 0x21, 0x31, 0x35, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x30
	0x21, 0x22, 0x30, 0x32, 0x35, 0x36, 0xff, 0xff, 0xff, 0xff, // 0x31
	0x22, 0x31, 0x33, 0x36, 0x37, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x32
	0x23, 0x32, 0x34, 0x38, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x33
	0x23, 0x24, 0x25, 0x33, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x34
	0x30, 0x31, 0x36, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x35
	0x31, 0x32, 0x35, 0x37, 0x3b, 0x3c, 0xff, 0xff, 0xff, 0xff, // 0x36
	0x32, 0x36, 0x38, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x37
	0x33, 0x37, 0x39, 0x3e, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x38
	0x25, 0x33, 0x34, 0x38, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x39
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3a
	0x35, 0x36, 0x3c, 0x41, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3b
	0x36, 0x37, 0x3b, 0x3d, 0x41, 0x42, 0xff, 0xff, 0xff, 0xff, // 0x3c
	0x37, 0x3c, 0x3e, 0x42, 0x43, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3d
	0x38, 0x3d, 0x3f, 0x44, 0x45, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3e
	0x25, 0x38, 0x39, 0x3e, 0x45, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x40
	0x3b, 0x3c, 0x42, 0x4e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x41
	0x3c, 0x3d, 0x41, 0x43, 0x48, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x42
	0x3d, 0x42, 0x44, 0x48, 0x49, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x43
	0x3e, 0x43, 0x45, 0x4a, 0x4b, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x44
	0x3e, 0x3f, 0x44, 0x46, 0x4b, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x45
	0xff, 0x45, 0x4c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x46
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x47
	0x42, 0x43, 0x49, 0x4e, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x48
	0x43, 0x48, 0x4a, 0x4f, 0x50, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x49
	0x44, 0x49, 0x4b, 0x52, 0x60, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4a
	0x44, 0x45, 0x4a, 0x4c, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4b
	0x46, 0x4b, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4d
	0x41, 0x48, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4e
	0x48, 0x49, 0x50, 0x54, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4f
	0x49, 0x4f, 0x57, 0x58, 0x60, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x50
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x51
	0x4a, 0x4b, 0x53, 0x58, 0x59, 0x60, 0xff, 0xff, 0xff, 0xff, // 0x52
	0x52, 0x59, 0x4c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x53
	0x4e, 0x4f, 0x55, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x54
	0x54, 0x56, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x55
	0x55, 0x57, 0x63, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x56
	0x4f, 0x50, 0x55, 0x56, 0x58, 0x64, 0xff, 0xff, 0xff, 0xff, // 0x57
	0x50, 0x52, 0x57, 0x60, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x58
	0x52, 0x53, 0x66, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x59
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5b
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5d
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5e
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5f
	0x4a, 0x50, 0x52, 0x58, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x60
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x61
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x62
	0x56, 0x64, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x63
	0x57, 0x63, 0x65, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x64
	0x58, 0x64, 0x69, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x65
	0x59, 0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x66
	0x63, 0x68, 0x6c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x67
	0x64, 0x67, 0x69, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x68
	0x65, 0x68, 0x6e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x69
	0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6a
	0x66, 0x6a, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6b
	0x67, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6c
	0x68, 0x6c, 0x6e, 0x71, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6d
	0x69, 0x6d, 0x72, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6e
	0x6b, 0x75, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x70
	0x6d, 0x72, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x71
	0x6e, 0x71, 0x73, 0x78, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x72
	0x72, 0x74, 0x79, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x73
	0x73, 0x75, 0x7a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x74
	0x6f, 0x74, 0x7a, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x75
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x76
	0x71, 0x78, 0x7c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x77
	0x72, 0x77, 0x79, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x78
	0x73, 0x78, 0x7a, 0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x79
	0x74, 0x75, 0x79, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7b
	0x77, 0x7d, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7c
	0x78, 0x7c, 0x7e, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7d
	0x79, 0x7d, 0x7f, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7e
	0x7a, 0x7e, 0x80, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7f
	0x75, 0x7f, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x80
	0x7c, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x81
	0x7d, 0x7e, 0x81, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x82
	0x7f, 0x80, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x83
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x84
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x85
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x86
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x87
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x88
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x89
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8b
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8d
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8e
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8f

	// ANSI model
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // sentinel
	0x01, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x00
	0x00, 0x02, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x01
	0x01, 0x03, 0x06, 0x07, 0x0c, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x02
	0x02, 0x04, 0x07, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x03
	0x03, 0x05, 0x08, 0x0a, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x04
	0x04, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x05
	0x00, 0x01, 0x02, 0x07, 0x0b, 0x0c, 0xff, 0xff, 0xff, 0xff, // 0x06
	0x02, 0x03, 0x06, 0x08, 0x0c, 0x0d, 0xff, 0xff, 0xff, 0xff, // 0x07
	0x03, 0x04, 0x07, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, // 0x08
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x09
	0x04, 0x05, 0x0f, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0a
	0x06, 0x0c, 0x11, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x0b
	0x06, 0x07, 0x0b, 0x0d, 0x11, 0x12, 0xff, 0xff, 0xff, 0xff, // 0x0c
	0x07, 0x08, 0x0c, 0x0e, 0x12, 0x13, 0xff, 0xff, 0xff, 0xff, // 0x0d
	0x08, 0x0d, 0x0f, 0x13, 0x14, 0x15, 0xff, 0xff, 0xff, 0xff, // 0x0e
	0x04, 0x08, 0x0a, 0x0e, 0x10, 0x15, 0xff, 0xff, 0xff, 0xff, // 0x0f
	0x0a, 0x0f, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x10
	0x0b, 0x0c, 0x12, 0x17, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x11
	0x0b, 0x0c, 0x0d, 0x11, 0x13, 0x17, 0x18, 0xff, 0xff, 0xff, // 0x12
	0x0d, 0x0e, 0x12, 0x14, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, // 0x13
	0x0e, 0x13, 0x15, 0x19, 0x1a, 0x1b, 0xff, 0xff, 0xff, 0xff, // 0x14
	0x0e, 0x0f, 0x10, 0x14, 0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x15
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x16
	0x11, 0x12, 0x18, 0x1c, 0x1d, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x17
	0x11, 0x12, 0x13, 0x17, 0x19, 0x1c, 0x1d, 0xff, 0xff, 0xff, // 0x18
	0x13, 0x14, 0x18, 0x1a, 0x1d, 0x1e, 0xff, 0xff, 0xff, 0xff, // 0x19
	0x14, 0x19, 0x1b, 0x1e, 0x1f, 0x20, 0xff, 0xff, 0xff, 0xff, // 0x1a
	0x14, 0x15, 0x1a, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1b
	0x17, 0x18, 0x1d, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x1c
	0x17, 0x18, 0x19, 0x1c, 0x1e, 0x21, 0xff, 0xff, 0xff, 0xff, // 0x1d
	0x19, 0x1a, 0x1d, 0x1f, 0x21, 0x22, 0xff, 0xff, 0xff, 0xff, // 0x1e
	0x1a, 0x1e, 0x20, 0x22, 0x23, 0x24, 0xff, 0xff, 0xff, 0xff, // 0x1f
	0x1a, 0x1b, 0x1f, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x20
	0x1d, 0x1e, 0x22, 0x30, 0x31, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x21
	0x1e, 0x1f, 0x21, 0x23, 0x31, 0x32, 0xff, 0xff, 0xff, 0xff, // 0x22
	0x1f, 0x22, 0x24, 0x32, 0x33, 0x34, 0xff, 0xff, 0xff, 0xff, // 0x23
	0x1f, 0x20, 0x23, 0x25, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x24
	0x20, 0x24, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x25
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x26
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x27
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x28
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x29
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2b
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2d
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2e
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x2f
	0x21, 0x31, 0x35, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x30
	0x21, 0x22, 0x30, 0x32, 0x35, 0x36, 0xff, 0xff, 0xff, 0xff, // 0x31
	0x22, 0x23, 0x31, 0x33, 0x36, 0x37, 0xff, 0xff, 0xff, 0xff, // 0x32
	0x23, 0x32, 0x34, 0x37, 0x38, 0x39, 0xff, 0xff, 0xff, 0xff, // 0x33
	0x23, 0x24, 0x25, 0x33, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x34
	0x30, 0x31, 0x36, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x35
	0x31, 0x32, 0x35, 0x37, 0x3b, 0x3c, 0xff, 0xff, 0xff, 0xff, // 0x36
	0x32, 0x33, 0x36, 0x38, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, // 0x37
	0x33, 0x37, 0x39, 0x3d, 0x3e, 0x3f, 0xff, 0xff, 0xff, 0xff, // 0x38
	0x33, 0x34, 0x38, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x39
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3a
	0x35, 0x36, 0x3c, 0x41, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3b
	0x36, 0x37, 0x3b, 0x3d, 0x41, 0x42, 0xff, 0xff, 0xff, 0xff, // 0x3c
	0x37, 0x38, 0x3c, 0x3e, 0x42, 0x43, 0xff, 0xff, 0xff, 0xff, // 0x3d
	0x38, 0x3d, 0x3f, 0x43, 0x44, 0x45, 0xff, 0xff, 0xff, 0xff, // 0x3e
	0x38, 0x39, 0x3e, 0x45, 0x46, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x3f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x40
	0x3b, 0x3c, 0x42, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x41
	0x3c, 0x3d, 0x41, 0x43, 0x48, 0x4e, 0xff, 0xff, 0xff, 0xff, // 0x42
	0x3d, 0x3e, 0x42, 0x44, 0x48, 0x49, 0xff, 0xff, 0xff, 0xff, // 0x43
	0x3e, 0x43, 0x45, 0x49, 0x4a, 0x4b, 0xff, 0xff, 0xff, 0xff, // 0x44
	0x3e, 0x3f, 0x44, 0x46, 0x4b, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x45
	0x3f, 0x45, 0x4b, 0x4c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x46
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x47
	0x42, 0x43, 0x49, 0x4e, 0x4f, 0x54, 0xff, 0xff, 0xff, 0xff, // 0x48
	0x43, 0x44, 0x48, 0x4a, 0x4f, 0x50, 0xff, 0xff, 0xff, 0xff, // 0x49
	0x44, 0x49, 0x4b, 0x50, 0x52, 0x58, 0xff, 0xff, 0xff, 0xff, // 0x4a
	0x44, 0x45, 0x4a, 0x4c, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4b
	0x45, 0x46, 0x4b, 0x52, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4d
	0x42, 0x48, 0x4f, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x4e
	0x48, 0x49, 0x4e, 0x50, 0x54, 0x55, 0x57, 0xff, 0xff, 0xff, // 0x4f
	0x49, 0x4a, 0x4f, 0x51, 0x57, 0x58, 0xff, 0xff, 0xff, 0xff, // 0x50
	0x50, 0x57, 0x58, 0x64, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x51
	0x4a, 0x4b, 0x53, 0x58, 0x59, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x52
	0x52, 0x59, 0x4c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x53
	0x48, 0x4e, 0x4f, 0x55, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x54
	0x4f, 0x54, 0x56, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x55
	0x55, 0x57, 0x63, 0x64, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x56
	0x4f, 0x50, 0x51, 0x55, 0x56, 0x63, 0x64, 0x65, 0xff, 0xff, // 0x57
	0x4a, 0x50, 0x51, 0x52, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x58
	0x52, 0x53, 0x66, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x59
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5b
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5d
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5e
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x5f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x60
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x61
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x62
	0x56, 0x57, 0x64, 0x67, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x63
	0x51, 0x56, 0x57, 0x63, 0x65, 0x67, 0x68, 0x69, 0xff, 0xff, // 0x64
	0x51, 0x57, 0x58, 0x64, 0x68, 0x69, 0xff, 0xff, 0xff, 0xff, // 0x65
	0x52, 0x59, 0x6a, 0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x66
	0x63, 0x64, 0x68, 0x6c, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x67
	0x63, 0x64, 0x65, 0x67, 0x69, 0x6c, 0x6d, 0x6e, 0xff, 0xff, // 0x68
	0x64, 0x65, 0x68, 0x6a, 0x6d, 0x6e, 0xff, 0xff, 0xff, 0xff, // 0x69
	0x65, 0x66, 0x69, 0x6b, 0x6e, 0x6f, 0xff, 0xff, 0xff, 0xff, // 0x6a
	0x66, 0x6a, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6b
	0x67, 0x68, 0x6d, 0x71, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6c
	0x67, 0x68, 0x69, 0x6c, 0x6e, 0x71, 0xff, 0xff, 0xff, 0xff, // 0x6d
	0x68, 0x69, 0x6d, 0x71, 0x72, 0x73, 0xff, 0xff, 0xff, 0xff, // 0x6e
	0x6a, 0x6b, 0x75, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x6f
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x70
	0x6c, 0x6d, 0x6e, 0x72, 0x77, 0x78, 0xff, 0xff, 0xff, 0xff, // 0x71
	0x6d, 0x6e, 0x71, 0x73, 0x77, 0x78, 0x79, 0xff, 0xff, 0xff, // 0x72
	0x6e, 0x72, 0x78, 0x79, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x73
	0x73, 0x75, 0x79, 0x7a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x74
	0x6f, 0x74, 0x7a, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x75
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x76
	0x71, 0x72, 0x78, 0x7c, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x77
	0x71, 0x72, 0x73, 0x77, 0x79, 0x7c, 0x7d, 0x7e, 0xff, 0xff, // 0x78
	0x72, 0x73, 0x74, 0x78, 0x7a, 0x7d, 0x7e, 0x7f, 0xff, 0xff, // 0x79
	0x73, 0x74, 0x75, 0x79, 0x7e, 0x7f, 0x80, 0xff, 0xff, 0xff, // 0x7a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7b
	0x77, 0x78, 0x7d, 0x81, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x7c
	0x77, 0x78, 0x79, 0x7c, 0x7e, 0x81, 0x82, 0xff, 0xff, 0xff, // 0x7d
	0x78, 0x79, 0x7a, 0x7d, 0x7f, 0x82, 0x83, 0xff, 0xff, 0xff, // 0x7e
	0x75, 0x79, 0x7a, 0x7e, 0x80, 0x82, 0x83, 0xff, 0xff, 0xff, // 0x7f
	0x75, 0x7a, 0x7f, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x80
	0x7c, 0x7d, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x81
	0x7c, 0x7d, 0x7e, 0x7f, 0x81, 0x83, 0xff, 0xff, 0xff, 0xff, // 0x82
	0x7e, 0x7f, 0x80, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x83
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x84
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x85
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x86
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x87
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x88
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x89
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8a
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8b
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8c
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8d
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // 0x8e
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff  // 0x8f
];

// #[rustfmt::skip]
// pub const ROWS_TOPOLOGY: [u8; 102] = [
//     // ISO model
//     0x02, 0x0d, 0x14, 0x19, 0x1e, 0x28, 0x2f, 0x35, 0x3b, 0x41, 0x47, 0x4d, 0x4f, 0x5c, 0xff, 0xff, 0xff,
//     0x03, 0x08, 0x0e, 0x15, 0x1a, 0x1f, 0x24, 0x29, 0x30, 0x36, 0x3c, 0x42, 0x48, 0x50, 0x54, 0x58, 0x5d,
//     0x04, 0x09, 0x0f, 0x16, 0x1b, 0x20, 0x25, 0x2a, 0x31, 0x37, 0x3d, 0x43, 0x49, 0x52, 0x55, 0x59, 0x5e,
//     0x05, 0x0a, 0x10, 0x17, 0x1c, 0x21, 0x26, 0x2b, 0x32, 0x38, 0x3e, 0x44, 0x4a, 0xff, 0xff, 0xff, 0xff,
//     0x00, 0x06, 0x0b, 0x11, 0x18, 0x1d, 0x22, 0x27, 0x2c, 0x33, 0x39, 0x3f, 0x4b, 0xff, 0x5a, 0xff, 0xff,
//     0x01, 0x07, 0x0c, 0x23, 0x3a, 0x40, 0x46, 0x4c, 0x56, 0x5b, 0x5f, 0x40, 0xff, 0xff, 0xff, 0xff, 0xff,

//     // ANSI model
//     // TODO: Implement this
// ];

// #[rustfmt::skip]
// pub static ROWS_TOPOLOGY: [u8; 127] = [
//     // ISO model
//     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x08, 0x0e, 0x15, 0x1a, 0xff, 0xff, 0xff, 0xff,
//     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x09, 0x0f, 0x16,
//     0x1b, 0x20, 0x25, 0x2a, 0x31, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//     0xff, 0xff, 0x05, 0x0a, 0x10, 0x17, 0x1c, 0x21, 0x26, 0x2b, 0x32, 0x38, 0x3e, 0x44, 0x4a, 0xff,
//     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x06, 0x0b, 0x11, 0x18, 0x1d, 0x22, 0x27,
//     0x2c, 0x33, 0x39, 0x3f, 0x4b, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x07,
//     0x0c, 0x23, 0x3a, 0x4c, 0x56, 0x5b, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
// ];

#[rustfmt::skip]
pub static ROWS_TOPOLOGY: [u8; 127] = [
    0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x08, 0x0e, 0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x09, 0x0f, 0x16,
    0x1b, 0x20, 0x25, 0x2a, 0x31, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x05, 0x0a, 0x10, 0x17, 0x1c, 0x21, 0x26, 0x2b, 0x32, 0x38, 0x3e, 0x44, 0x4a, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x06, 0x0b, 0x11, 0x18, 0x1d, 0x22, 0x27,
    0x2c, 0x33, 0x39, 0x3f, 0x4b, 0xff, 0x5a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x07,
    0x0c, 0x23, 0x3a, 0xff, 0x4c, 0x56, 0x5b, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

#[rustfmt::skip]
pub static COLS_TOPOLOGY: [u8; 127] = [
    0xff, 0x03, 0x04, 0x05, 0x00, 0x01, 0xff, 0x08, 0x09, 0x0a, 0x06, 0x07, 0x0d, 0x0e, 0x0f, 0x10,
    0x0b, 0x0c, 0x14, 0x15, 0x16, 0x17, 0x11, 0x11, 0x1e, 0x1f, 0x1b, 0x1c, 0x1d, 0xff, 0xff, 0x24,
    0x20, 0x21, 0x22, 0x23, 0x28, 0x29, 0x25, 0x26, 0x27, 0xff, 0x2f, 0x30, 0x2a, 0x2b, 0x2c, 0xff,
    0x3b, 0x36, 0x37, 0x38, 0x33, 0xff, 0xff, 0xff, 0x3c, 0x3d, 0x3e, 0x39, 0x41, 0x42, 0x43, 0x44,
    0x3f, 0xfe, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0xff, 0x4d, 0x50, 0x52, 0x4b, 0x4c, 0xff, 0xfe, 0x54,
    0x55, 0xff, 0xff, 0x56, 0xfe, 0x58, 0x59, 0xff, 0x5a, 0x5b, 0xfe, 0x5d, 0x5e, 0xff, 0xff, 0x5f,
    0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe,
    0xfe, 0xfe, 0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

// #[rustfmt::skip]
// pub const COLS_TOPOLOGY: [u8; 108] = [
//     // ISO model
//     0x02, 0x03, 0x04, 0x05, 0x00, 0x01,
//     0x08, 0x09, 0x0a, 0x06, 0x07, 0xff,
//     0x0d, 0x0e, 0x0f, 0x10, 0x0b, 0x0c,
//     0x14, 0x15, 0x16, 0x17, 0x11, 0xff,
//     0x19, 0x1a, 0x1b, 0x1c, 0x18, 0xff,
//     0x1e, 0x1f, 0x20, 0x21, 0x1d, 0xff,
//     0xff, 0x24, 0x25, 0x26, 0x22, 0x23,
//     0x28, 0x29, 0x2a, 0x2b, 0x27, 0xff,
//     0x2f, 0x30, 0x31, 0x32, 0x2c, 0xff,
//     0x35, 0x36, 0x37, 0x38, 0x33, 0xff,
//     0x3b, 0x3c, 0x3d, 0x3e, 0x39, 0x3a,
//     0x41, 0x42, 0x43, 0x44, 0x3f, 0x40,
//     0x47, 0x48, 0x49, 0x4a, 0x4b, 0x46,
//     0x4d, 0x50, 0x52, 0xff, 0x4c, 0xff,
//     0x4f, 0x54, 0x55, 0xff, 0xff, 0x56,
//     0x5c, 0x58, 0x59, 0xff, 0x5a, 0x5b,
//     0xff, 0x5d, 0x5e, 0xff, 0x40, 0x5f,
//     0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

//     // ANSI model
//     // TODO: Implement this
// ];
